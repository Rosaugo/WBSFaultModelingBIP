
\section{Introduction}
\label{introduction}


Design, manufacture and verification of large scale reliable hardware/software systems (e.g. cyber-physical systems) 
remains a grand challenge in system design automation~\cite{sifakis2015}.
To address this challenge, the rigorous system design methodology~\cite{sifakis13}.
Rigorous system design can be understood as a formal, accountable and coherent process for deriving correct and trustworthy system implementations from high-level specifications.
The essential safety properties of the design are guaranteed at the earliest possible design phase by applying algorithmic verification to the system model,
 and then the system implementation is automatically generated by a sequence of property preserving model transformations, progressively refining the model with details specific to the target platforms.


The architecture-based design approach consists of the three stages.
First, architecture styles relevant for the application domain are identified and formally modelled. 
Ideally, this stage is only realised once for each application domain. The remaining stages are applied for each system to be designed. 
In the second design stage, requirements to be satisfied by the system are analysed and formalised,
atomic components realising the basic functionality of the system are designed
(components previously designed for other systems can be reused) and used as
operands for the application of architectures instantiated from the styles defined in the first stage. 
The choice of the architectures to apply is driven by the requirements identified in the second stage. 
Finally, the resulting system is checked for deadlock-freedom. 
Properties, which are not enforced by construction through architecture application, must be verified a posteriori. 
In this case study, we illustrate all steps of this process, except the requirement formalisation.


The Behavior-Interaction-Priority (BIP) framework~\cite{bip11} is proposed as a component-based system design framework, 
which comes with a formal language with well-defined semantics and a tool chain supporting rigorous system design process.
The BIP language offers a three-layered modeling mechanism for constructing complex system behavior and architectures~\cite{concur16}, i.e.,  Behavior, Interaction, and Priority.
%
Behavior is characterized by a set of components, which are formally defined as automata extended with linear arithmetic.
Interaction specifies the multiparty synchronization of components, among which data transfer may take place.
Priority can be used to schedule the interactions or resolve conflicts when several interactions are enabled simultaneously.
The key insight underlying this three-layered modeling mechanism is the principle of separation of concerns,
 that is, system computation is captured by a set of components, and system coordination is modeled by interaction and priority.


BIP framework advocates component-based design of correct-by-construction applications.
It provides a simple, but powerful mechanism for the coordination of concurrent components by superposing three layers.
First, component behaviour is described by Labelled Transition Systems (LTS) having transitions labelled with ports.
Ports form the interface of a component and are used to define its interactions with other components.
Second, interaction models, i.e. sets of interactions, define the component coordination.
Interactions are sets of ports that define allowed synchronizations between components.
An interaction model is defined in a structured manner by using connectors.
Third, priorities are used to impose scheduling constraints and to resolve conflicts when multiple interactions are enabled simultaneously.


The BIP tool chain supports both algorithmic verification and testing of high-level system designs ~\cite{dfinder10,atva15,tgc15}
 and automatic system synthesis of low-level implementations from high-level system designs~\cite{bip-emsoft10}.
 In practice, BIP has been actively used in several applications~\cite{bipapplication12a,bipapplication18}.


The rest of the paper is structured as follows.
%
In Section~\ref{sec:preliminary} and Section~\ref{sec:bip}, we introduce the preliminaries and the BIP modeling language.
%
In Section~\ref{sec:relatework} and Section~\ref{sec:conclusions}, we review the most related works and draw some conclusions and outline directions for future work.

