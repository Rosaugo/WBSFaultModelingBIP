
\section{BIP framework}
\label{sec:rsd}

In this section, we present the BIP framework.
 In BIP framework, a model is constructed by composing three layers of modeling, that is behavior, interaction and priority.
 More information about the underlying concepts and the operational semantics of BIP can be found in \cite{}.
 In particular, BIP provides separation of concerns between behavioral and architectural aspects in modeling.
% For BIP components, architecture is meaningfully defined as the combination of interactions and priorities.
% Component architecture can therefore be easily decoupled, understood and analyzed independently of the associated behavior.


The Behavior-Interaction-Priority (BIP) framework~\cite{bip11} is proposed as a component-based system design framework,
which comes with a formal language with well-defined semantics and a tool chain supporting rigorous system design process.
The BIP language offers a three-layered modeling mechanism for constructing complex system behavior and architectures~\cite{concur16}, i.e.,  Behavior, Interaction, and Priority.
%
Behavior is characterized by a set of components, which are formally defined as automata extended with linear arithmetic.
Interaction specifies the multiparty synchronization of components, among which data transfer may take place.
Priority can be used to schedule the interactions or resolve conflicts when several interactions are enabled simultaneously.
The key insight underlying this three-layered modeling mechanism is the principle of separation of concerns,
 that is, system computation is captured by a set of components, and system coordination is modeled by interaction and priority.

 An atomic component is described by a finite-state automata extended with variables and ports, 
 where variables are used to store local data, and ports form the interface of the component.
 Ports are used to define the interaction and communication with other components, and may be associated with variables.
 Moreover, ports also serve as the labels of the automata transitions.
 States denote control locations at which the components await for interaction. 
 A transition is a step, labeled by a port, from a control location to another. 
 It may be associated a guard (i.e. a boolean expression) and an action (i.e., a function over variables). 
 In BIP, actions are written in C/C++.
 An example BIP component is shown in Fig.\ref{}.
 

Composition of components is defined by interactions.
 Essentially, interactions express synchronization constraints between transitions of the composed components.
 Interactions are described in BIP as the combination of two types of elementary protocols: 
 rendezvous to express strong symmetric synchronization and broadcast to express triggered asymmetric synchronization.
 Interactions are structured in connectors, that is, sets of ports plus additional information. 
 Within connectors, every port is typed either as synchron or as trigger. 
 Trigger ports are used to initiate broadcast, that is, any subset of ports containing at least one trigger port denote a valid interaction of the connector. 
 Rendezvous synchronizations are obtained on connectors where all the ports are synchrons. 
 For such connectors, the only valid interaction is the maximal one, that is, the whole set of ports. 
 Finally, connectors provide mechanisms for dealing with data associated to (ports of) interacting components. 
 Every interaction has a guard, that is, an enabling condition and an action, that is, an update (data transfer) function, 
 operating on data associated to ports participating in the interaction.
 Circles (resp. triangles) denote synchron (resp. trigger) ports.


Priorities are used to filter amongst possible interactions. 
 They are expressed as conditional priority rules between two interactions.
 Whenever the condition (on the state of the system) holds, and if the two interactions are enabled at the same time, 
  then only the high priority interaction is allowed for execution.
  In practice, priorities steer system evolution so as to meet performance requirements e.g. to express scheduling policies.
 

The BIP toolbox includes a rich set of tools for modeling, transformation, analysis and code generation of models.
 The toolbox provides a dedicated modeling language for describing BIP components.
 It is a user-friendly textual language which provides syntactic constructs for describing components conforming to the formal framework. 
 The BIP language leverages on C-style expression declarations, and provides additional syntactic constructs for defining component behavior, 
 specifying the coordination through connectors, and describing the priorities.
%
 The toolbox also provides front-end tools for editing and parsing of BIP descriptions, as well as for generating intermediate models, followed by code generation (in C++). 
 Intermediate models can be subject to various model transformations focusing on construction of optimized models for respectively sequential and distributed execution. 
 Back-end tools include specific runtime for efficient execution on machines with different characteristics (e.g., real-time, mono/multi-thread, single/multi-core).
%
Besides, various analysis tools are provided to perform validation and verification of BIP models, 
 such as deadlock analysis using the D-Finder tool \cite{dfinder10}, reachability analysis using the model checker  \cite{atva15}  and the runtime verification tool \cite{}. 
% D-Finder implements state-of-the-art compositional methods [10] for computing invariants for systems consisting of interacting components. 
% Invariants are safe (over) approximations of the set of reachable states of the system and can be used to prove safety requirements. 
% In the case of BIP components, invariants computed are conjunctions of local invariants for atomic components and interaction invariants characterizing the interactions glue. 
% Local component invariants are generated by static (and individual) analysis of atomic components.
% Interaction invariants are generated from abstractions of the interacting components and the interactions glue.
%
% Runtime validation techniques available for BIP are based on construction and execution of monitored systems. 
% Historically this validation approach is oriented towards finding errors rather than proving their absence from designs.
% This approach has been adapted for BIP components as explained in [11]. 
% It consists in constructing an executable model of the designed system together with monitors responsible for evaluation of safety requirements. 
% Monitors are atomic components that sense the system state (through interaction with system¡¯s components) 
% and react by moving to error states whenever the safety requirement is violated
% i.e., if an inconsistent state is reached or an invalid sequence of interactions has been executed, etc. 
% The BIP framework provides native support for building and running executable models for monitored systems.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\iffalse

We use architecture diagrams \cite{} to model the architecture styles in BIP.
An architecture diagram consists of a set of component types,
 with associated cardinality constraints representing the expected number of instances of each component type and a set of connector motifs.
 Connector motifs, which define sets of BIP connectors, are non-empty sets of port types, each labelled as either a trigger or a synchron.
 Each port type has a cardinality constraint representing the expected number of port instances per component instance and two additional constraints: multiplicity and degree,
 represented as a pair m : d. Multiplicity constrains the number of instances of the port type that must participate in a connector defined by the motif;
 degree constrains the number of connectors attached to any instance of the port type.

In this section, we present the BIP model with multiparty synchronization and data transfer.
%
%we denote by $\varstate{}[x := e]$ the substitution of variable $x$ by expression $e$ in valuation $\varstate{}$.
%
A BIP model is a parallel composition of a set of components.
A BIP component is formally defined as an automaton extended with linear integer arithmetic as follows.

\begin{definition} [BIP component]
\label{component-def}
Given a finite set of variables $\bipvar{}$, a BIP component is defined as a tuple
 $\comp{} = \mktuple{\bipvar{}, \locs{}, \ports{}, \edges{}, \ell}$, where
\begin{inparaenum}
\item $\locs{}$ is a finite set of control locations;
\item $\ports{}$ is a finite set of communication ports;
\item $\edges{} \subseteq \locs{} \times \ports{} \times \bexp{\bipvar{}} \times \expr{\bipvar{}} \times \locs{}$
 is a finite set of transition edges extended with guards in $\bexp{\bipvar{}}$
 and operations in $\expr{\bipvar{}}$;
\item $\ell \in \locs{}$ is an initial control location.
\end{inparaenum}
\end{definition}


Transition edges in a component are labeled by ports, which form the interface of the component.
 We assume that, from each control location,
 every pair of outgoing transitions have different ports,
 and the ports of different components are disjoint.
 In other words, transitions with the same ports in the component are not enabled simultaneously.
 Given a component violating such assumptions,
 one can easily transform it into the required form by renaming the ports,
 while retaining the BIP expressiveness power.
 To ease the presentation, we denote in the sequel the id of the unique component
 where port $p$ is defined by $\portid{p}$.

%Given a tuple of component types $\overline{\comptype{}} = \mktuple{\comptype{1},\ldots, \comptype{k}}$,
%and a tuple of natural numbers $\overline{n} = \mktuple{n_{1}, \ldots, n_{k}}$,
%where $n_{i}$ represents the number of instantiations of $\comptype{i}$,
%

We denote by $\components = \{\comp{i} ~|~ i\in [1,n]\}$ a set of components.
%instantiated from $\overline{\comptype{}}$.
%where $\comptype{i}[j]$
%$\comptype{i}[j] = \mktuple{\bipvar{i}[j] ,\locs{i}[j] ,\ports{i}[j], \edges{i}[j], \ell_{i}[j] }$
%is the $j^{th}$ instantiation of component type $\comptype{i}$.
%
%Given a set of comoponents $\components$,
In \BIP, coordinations of components are specified by using interactions.
%and in \BIP an interaction is represented as a finite set of ports.

\begin{definition} [Interaction]
\label{interaction}
An interaction for $\components $ is a tuple $\gamma = \mktuple{g, \mathcal{P}, f } $,
where $g \in \bexp{\bipvar{}}$, $f\in \expr{\bipvar{}}$ and
$\mathcal{P} \subseteq \bigcup_{i=1}^n \ports{i}$, $\mathcal{P} \neq \emptyset$, and
for all $i \in [1, n]$, $|\mathcal{P} \cap \ports{i}| \le 1$.
\end{definition}

Intuitively, an interaction defines a guarded multiparty synchronization with data transfer:
when the guard $g$ of an interaction $\mathcal{P}$ is enabled,
then the data transfer specified by $f$ can be executed, and
after that the transitions labelled by the ports in $\gamma$ can be taken simultaneously.
%
We denote by $\Gamma$ a finite set of interactions.
A \BIP model is constructed by composing a number of components with interactions.

\begin{definition} [\BIP Model]
A \BIP model $\bipmodel$ is a tuple $\mktuple{\components,\Gamma}$,
 where $\components$ is a finite set of components,
 and $\Gamma$ is a finite set of interactions for $\components$.
\end{definition}

We do not take priority into account in this paper, as in the previous work~\cite{dfinder10,tgc15},
 since adding priority will not introduce any errors.
 If a model without priority is safe, then after adding priority constraints it remains safe.
 We use a simple mutual exclusion protocol to illustrate \BIP.

%\input{ticket-bip}

A state of a \BIP model is a tuple $c = \langle \compstate{1}, \ldots, \compstate{n} \rangle $,
 where for all $i \in [1,n] $, $l_i \in \locs{i} $ and $\mathbf{V}_i $ is a valuation of $\bipvar{i}$.
%
%We denote by $c(i,j), i\in[1,k]$ the state $\mktuple{l_{i}^{j}, s_{i}^{j}}$ of component $\comptype{i}[j]$.
%$c_0=\mktuple{\mktuple{l_1,s_1},\ldots, \ldots, \mktuple{l_n,s_n}}$
A state $c_{0}$ is initial if for all $i \in [1,n]$,
$l_i = \ell_{i}$ and $\mathbf{V}_{i}$ is the initial valuation of $\bipvar{i}$.
%
A state $c$ is an error if for some $i \in [1,n]$, $l_{i}$ is an error location.
%
We say an interaction $\gamma \in \Gamma$ is enabled on a state $c$ if
 for every component $\comp{i} \in \components$,
 such that $\gamma \cap \ports{i} \neq \emptyset$,
%
 there is an edge $\mktuple{l_i, \gamma \cap \ports{i}, g_i, f_i, l_{i}' } \in \edges{i}$
 and  $\mathbf{V}_{i} \models g_i $.
%
The labeled transition system semantics of a \BIP model is defined as follows.

\begin{definition} [\BIP operational semantics]
\label{operational-semantics}
Given a \BIP model $\bipmodel=\mktuple{\components,\Gamma}$,
 its operational semantics is defined by a labeled transition system
 $\TS{\BIP} = \mktuple{\mathcal{C}, \Sigma, \mathcal{R}, \mathcal{C}_{0}}$, where
%
\begin{enumerate}
\item $\mathcal{C}$ is the set of states,
\item $\Sigma = \Gamma $,
\item $\mathcal{R}$ is the set of transitions,
  and we say that there is a transition from a state $c$
%$c=\mktuple{\mktuple{l_1,s_1}, \ldots, \mktuple{l_n,s_n}} $
  to another state $c'$,
%$c'=\mktuple{\mktuple{l_1',s_1'}, \ldots, \mktuple{l_n',s_n'}}$
  if there is an interaction $\gamma $ such that,
%
\begin{enumerate}
%\begin{inparaenum}[(i)]
  \item $\gamma$ is enabled in $c$;
  \item for all $\comp{i} \in \mathbb{B}$ such that
    $\gamma \cap \ports{i} \neq \emptyset$, there is an edge
    $\mktuple{l_i, \gamma \cap \ports{i}, g_i, f_i, l_i'} \in \edges{i} $,
    %and if $f_i = x := e $,
    then $\mathbf{V}'_{i} = \mathbf{V}_{i}[\bipvar{} / f_i(\bipvar{})]$;
  \item for all $\comp{i} \in \mathbb{B} $ such that
    $\gamma \cap \ports{i} = \emptyset $,
    $l_i' = l_i$ and $\mathbf{V}_i' = \mathbf{V}_i$.
%\end{inparaenum}
\end{enumerate}
\item $\mathcal{C}_{0}$ is the set of initial states.
\end{enumerate}
\end{definition}

%We denote by $c \overset{\gamma} \rightarrow c'$ that
%there is a transition from state $c$ to state $c'$, following the interaction $\gamma$.
%
%We denote by $\rho$
%
%A state $c$ % $c=\mktuple{\mktuple{l_1,s_1}, \ldots, \mktuple{l_n,s_n}}$
%is reachable if there is a trace
%$c_0, c_1, \ldots, c_k$ such that
%$c_0 \xrightarrow{\gamma_1} c_1 \xrightarrow{\gamma_2} \ldots \xrightarrow{\gamma_k} c $,
%from an initial configuration $c_{0}$ to $ c$.
%
In this paper, we do not use temporal logics to specify safety properties,
 but recognize a set of locations as error locations.
 A \BIP model is safe if no error states are reachable.
 Notice that any safety property can be encoded as a reachability
 problem by necessarily creating additional components.

\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
